<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Room Cleanup</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;font-family:'Segoe UI',system-ui,sans-serif}
body{-webkit-user-select:none;user-select:none;touch-action:none;background:#1a1a2e}

#roomCanvas{position:absolute;inset:0;width:100%;height:100%;z-index:0}

.game-layer{position:absolute;inset:0;z-index:10}

.target-zone{
  position:absolute;
  border:3px dashed rgba(255,255,255,.4);
  border-radius:16px;
  background:rgba(255,255,255,.05);
  display:flex;align-items:center;justify-content:center;flex-direction:column;
  pointer-events:none;
  transition:all .3s ease;
}
.target-zone.active{
  border-color:rgba(100,255,100,.8);
  background:rgba(100,255,100,.12);
  box-shadow:0 0 28px rgba(100,255,100,.3);
}
.target-zone.filled{
  border-color:rgba(100,255,100,.5);
  background:rgba(100,255,100,.08);
  border-style:solid;
}
.target-label{
  font-size:clamp(10px,1.3vw,13px);font-weight:700;
  color:rgba(255,255,255,.5);text-align:center;
  pointer-events:none;margin-top:4px;
}
.target-ghost{font-size:clamp(24px,3vw,36px);opacity:.2;pointer-events:none}
.target-zone.filled .target-label,.target-zone.filled .target-ghost{display:none}

.drag-item{
  position:absolute;cursor:grab;z-index:100;
  font-size:clamp(48px,6vw,72px);line-height:1;
  filter:drop-shadow(0 4px 8px rgba(0,0,0,.3));
  transition:transform .2s ease,filter .2s ease;
}
.drag-item:hover{filter:drop-shadow(0 6px 16px rgba(0,0,0,.4)) brightness(1.1)}
.drag-item.dragging{
  z-index:500;cursor:grabbing;
  filter:drop-shadow(0 14px 30px rgba(0,0,0,.5)) brightness(1.15);
  transition:none;
}
.drag-item.placed{
  cursor:default;z-index:50;
  animation:snapIn .45s ease;
}
.drag-item.wrong{animation:reject .45s ease}

@keyframes snapIn{
  0%{transform:scale(.5);opacity:.5}
  60%{transform:scale(1.15)}
  100%{transform:scale(1);opacity:1}
}
@keyframes reject{
  0%,100%{transform:translateX(0)}
  20%{transform:translateX(-16px) rotate(-4deg)}
  40%{transform:translateX(14px) rotate(4deg)}
  60%{transform:translateX(-10px) rotate(-2deg)}
  80%{transform:translateX(6px) rotate(1deg)}
}

.hud{
  position:absolute;top:14px;left:14px;right:14px;
  display:flex;justify-content:space-between;align-items:flex-start;
  z-index:600;pointer-events:none;
}
.hud>*{pointer-events:auto}
.hud-box{
  background:rgba(0,0,0,.5);backdrop-filter:blur(12px);
  border:2px solid rgba(255,255,255,.12);
  border-radius:14px;padding:10px 18px;text-align:center;
}
.hud-label{font-size:11px;color:rgba(255,255,255,.45);text-transform:uppercase;letter-spacing:1px}
.hud-val{font-size:clamp(20px,3vw,28px);font-weight:800;color:white}

.room-title{
  position:absolute;top:14px;left:50%;transform:translateX(-50%);
  font-size:clamp(16px,2.5vw,24px);font-weight:800;
  color:white;text-shadow:0 2px 10px rgba(0,0,0,.5);
  z-index:600;pointer-events:none;
  padding:8px 22px;
  background:rgba(0,0,0,.45);backdrop-filter:blur(10px);
  border:2px solid rgba(255,255,255,.12);border-radius:16px;
}

.btn-back{
  position:absolute;bottom:16px;left:16px;
  padding:12px 26px;font-size:14px;font-weight:700;
  background:rgba(0,0,0,.5);backdrop-filter:blur(10px);
  border:2px solid rgba(255,255,255,.18);
  color:white;border-radius:30px;cursor:pointer;z-index:600;
  transition:all .3s;
}
.btn-back:hover{background:rgba(0,0,0,.7);transform:scale(1.05)}

.progress-wrap{
  position:absolute;bottom:16px;left:50%;transform:translateX(-50%);
  width:clamp(180px,30vw,320px);z-index:600;text-align:center;
}
.progress-bar{
  width:100%;height:10px;
  background:rgba(0,0,0,.35);
  border:2px solid rgba(255,255,255,.12);
  border-radius:10px;overflow:hidden;
}
.progress-fill{height:100%;border-radius:10px;transition:width .35s ease;width:0}
.progress-text{font-size:11px;font-weight:600;color:rgba(255,255,255,.55);margin-top:4px}

.overlay{
  position:fixed;inset:0;background:rgba(0,0,0,.82);
  display:none;justify-content:center;align-items:center;z-index:5000;
}
.overlay.show{display:flex}
.overlay-box{
  text-align:center;padding:clamp(28px,4vw,48px);
  border-radius:28px;max-width:480px;width:90%;
  animation:boxPop .45s ease;
}
@keyframes boxPop{
  0%{transform:scale(.5) rotate(-4deg);opacity:0}
  60%{transform:scale(1.06) rotate(1deg)}
  100%{transform:scale(1) rotate(0);opacity:1}
}
.overlay-title{font-size:clamp(28px,5vw,42px);font-weight:800;margin-bottom:10px}
.overlay-msg{font-size:clamp(15px,2.5vw,20px);margin-bottom:24px;line-height:1.6;color:#333}
.overlay-btn{
  padding:14px 36px;font-size:18px;font-weight:700;
  border:none;border-radius:50px;
  cursor:pointer;transition:all .3s;margin:6px;
  box-shadow:0 4px 16px rgba(0,0,0,.2);
}
.overlay-btn:hover{transform:scale(1.06)}
.overlay-btn.primary{background:#43a047;color:white}
.overlay-btn.secondary{background:rgba(0,0,0,.08);color:#333;border:2px solid rgba(0,0,0,.15)}

.sparkle{
  position:absolute;pointer-events:none;z-index:400;
  font-size:20px;
  animation:sparkleOut .7s ease-out forwards;
}
@keyframes sparkleOut{
  0%{transform:translate(0,0) scale(1);opacity:1}
  100%{transform:translate(var(--sx),var(--sy)) scale(0);opacity:0}
}
</style>
</head>
<body>
<canvas id="roomCanvas"></canvas>
<div class="game-layer" id="gameLayer">
  <div class="hud">
    <div class="hud-box">
      <div class="hud-label">Sorted</div>
      <div class="hud-val" id="scoreVal">0/5</div>
    </div>
    <div class="hud-box">
      <div class="hud-label">Time</div>
      <div class="hud-val" id="timerVal">0:00</div>
    </div>
  </div>
  <div class="room-title" id="roomTitle">Room</div>
  <div class="progress-wrap">
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <div class="progress-text" id="progressText">0 / 5 items placed</div>
  </div>
  <button class="btn-back" onclick="location.href='../index.html'">Menu</button>
</div>

<div class="overlay" id="winOverlay">
  <div class="overlay-box" id="overlayBox">
    <div class="overlay-title" id="overlayTitle"></div>
    <div class="overlay-msg" id="overlayMsg"></div>
    <div>
      <button class="overlay-btn primary" onclick="location.reload()">Play Again</button>
      <button class="overlay-btn secondary" onclick="location.href='../index.html'">Menu</button>
    </div>
  </div>
</div>

<script>
const params = new URLSearchParams(window.location.search);
const roomType = params.get('room') || 'bedroom';
const cvs = document.getElementById('roomCanvas');
const ctx = cvs.getContext('2d');
const gameLayer = document.getElementById('gameLayer');
let W, H;

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

const BEDROOM_POOL = [
  { emoji:'üß∏', name:'Teddy Bear', targetX:.20, targetY:.38, targetW:90, targetH:90, targetLabel:'On the bed' },
  { emoji:'üìö', name:'Books', targetX:.64, targetY:.36, targetW:80, targetH:75, targetLabel:'On the desk' },
  { emoji:'üëü', name:'Shoes', targetX:.86, targetY:.80, targetW:95, targetH:65, targetLabel:'By the door' },
  { emoji:'‚è∞', name:'Alarm Clock', targetX:.40, targetY:.40, targetW:70, targetH:70, targetLabel:'Nightstand' },
  { emoji:'üéí', name:'Backpack', targetX:.80, targetY:.42, targetW:80, targetH:85, targetLabel:'On shelf' },
  { emoji:'üß¢', name:'Cap', targetX:.76, targetY:.28, targetW:75, targetH:70, targetLabel:'On the hook' },
  { emoji:'üéÆ', name:'Controller', targetX:.58, targetY:.38, targetW:80, targetH:70, targetLabel:'On the desk' },
  { emoji:'üí°', name:'Lamp', targetX:.36, targetY:.34, targetW:70, targetH:80, targetLabel:'Nightstand' }
];

const KITCHEN_POOL = [
  { emoji:'üç≥', name:'Frying Pan', targetX:.28, targetY:.42, targetW:100, targetH:80, targetLabel:'On the stove' },
  { emoji:'üçΩÔ∏è', name:'Plate', targetX:.50, targetY:.38, targetW:85, targetH:85, targetLabel:'On counter' },
  { emoji:'‚òï', name:'Cup', targetX:.44, targetY:.42, targetW:70, targetH:75, targetLabel:'On counter' },
  { emoji:'üçé', name:'Apple', targetX:.62, targetY:.42, targetW:65, targetH:65, targetLabel:'Fruit bowl' },
  { emoji:'üßπ', name:'Broom', targetX:.88, targetY:.70, targetW:70, targetH:100, targetLabel:'By the wall' },
  { emoji:'üßΩ', name:'Sponge', targetX:.52, targetY:.44, targetW:65, targetH:60, targetLabel:'By the sink' },
  { emoji:'ü´ñ', name:'Teapot', targetX:.36, targetY:.38, targetW:80, targetH:75, targetLabel:'On shelf' },
  { emoji:'ü•Ñ', name:'Spoon', targetX:.42, targetY:.46, targetW:60, targetH:70, targetLabel:'In drawer' }
];

const LIVING_POOL = [
  { emoji:'üì±', name:'Remote', targetX:.38, targetY:.62, targetW:60, targetH:90, targetLabel:'Coffee table' },
  { emoji:'ü™¥', name:'Plant', targetX:.55, targetY:.28, targetW:75, targetH:85, targetLabel:'By window' },
  { emoji:'üìñ', name:'Magazine', targetX:.82, targetY:.34, targetW:70, targetH:75, targetLabel:'On shelf' },
  { emoji:'üöó', name:'Toy Car', targetX:.10, targetY:.82, targetW:90, targetH:65, targetLabel:'Toy box' },
  { emoji:'üß©', name:'Puzzle', targetX:.80, targetY:.50, targetW:75, targetH:75, targetLabel:'On shelf' },
  { emoji:'üéÆ', name:'Controller', targetX:.52, targetY:.48, targetW:75, targetH:70, targetLabel:'TV stand' },
  { emoji:'üß∏', name:'Stuffed Toy', targetX:.22, targetY:.48, targetW:85, targetH:85, targetLabel:'On sofa' },
  { emoji:'üïØÔ∏è', name:'Candle', targetX:.42, targetY:.58, targetW:60, targetH:75, targetLabel:'On table' }
];

const ROOMS = {
  bedroom: {
    name:'Bedroom Cleanup', pool:BEDROOM_POOL, count:5,
    progressColor:'linear-gradient(90deg,#ef9a9a,#e53935)',
    overlayBg:'linear-gradient(135deg,#FFF3E0,#FFE0B2)',
    overlayBorder:'#FFB74D', overlayTitleColor:'#E65100',
    wall1:'#F5E6D3', wall2:'#ECD9C6', backWall1:'#EDE0D4', backWall2:'#E3D5C7',
    floor1:'#B5895A', floor2:'#9E7548', trim:'#6D4C41',
    drawRoom: drawBedroom
  },
  kitchen: {
    name:'Kitchen Cleanup', pool:KITCHEN_POOL, count:5,
    progressColor:'linear-gradient(90deg,#FFE082,#FFA000)',
    overlayBg:'linear-gradient(135deg,#FFFDE7,#FFF9C4)',
    overlayBorder:'#FFD54F', overlayTitleColor:'#F57F17',
    wall1:'#FFFEF5', wall2:'#FFF8E1', backWall1:'#FFFDE7', backWall2:'#FFF9C4',
    floor1:'#D7CCC8', floor2:'#BCAAA4', trim:'#795548',
    drawRoom: drawKitchen
  },
  living: {
    name:'Living Room Cleanup', pool:LIVING_POOL, count:5,
    progressColor:'linear-gradient(90deg,#A5D6A7,#43A047)',
    overlayBg:'linear-gradient(135deg,#E8F5E9,#C8E6C9)',
    overlayBorder:'#81C784', overlayTitleColor:'#2E7D32',
    wall1:'#EDF5EE', wall2:'#DCE8DD', backWall1:'#E8F0E9', backWall2:'#D4E4D6',
    floor1:'#C4A882', floor2:'#B09670', trim:'#5D4037',
    drawRoom: drawLiving
  }
};

const config = ROOMS[roomType] || ROOMS.bedroom;
const selectedItems = shuffle(config.pool).slice(0, config.count);
let placedCount = 0;
const totalItems = selectedItems.length;
let elapsed = 0, timerInterval = null, gameOver = false;
let itemEls = [], targetEls = [];

function resize() {
  W = cvs.width = window.innerWidth;
  H = cvs.height = window.innerHeight;
  config.drawRoom(ctx, W, H, config);
}
window.addEventListener('resize', resize);

function perspectiveRoom(ctx, W, H, cfg) {
  const bwL = W * 0.15, bwR = W * 0.85, bwT = H * 0.10, bwB = H * 0.56;

  const wallGrad = ctx.createLinearGradient(0, 0, 0, H);
  wallGrad.addColorStop(0, cfg.wall1);
  wallGrad.addColorStop(1, cfg.wall2);
  ctx.fillStyle = wallGrad;
  ctx.fillRect(0, 0, W, H);

  const backGrad = ctx.createLinearGradient(bwL, bwT, bwL, bwB);
  backGrad.addColorStop(0, cfg.backWall1);
  backGrad.addColorStop(1, cfg.backWall2);
  ctx.fillStyle = backGrad;
  ctx.fillRect(bwL, bwT, bwR - bwL, bwB - bwT);

  const wY = bwT + (bwB - bwT) * 0.65;
  ctx.fillStyle = cfg.trim + '18';
  ctx.fillRect(bwL, wY, bwR - bwL, bwB - wY);
  ctx.strokeStyle = cfg.trim + '30';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(bwL, wY); ctx.lineTo(bwR, wY); ctx.stroke();

  ctx.fillStyle = cfg.wall1;
  ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(bwL, bwT); ctx.lineTo(bwL, bwB); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();
  const lwGrad = ctx.createLinearGradient(0, 0, bwL, 0);
  lwGrad.addColorStop(0, 'rgba(0,0,0,.06)');
  lwGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = lwGrad;
  ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(bwL, bwT); ctx.lineTo(bwL, bwB); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();

  ctx.fillStyle = cfg.wall2;
  ctx.beginPath(); ctx.moveTo(W, 0); ctx.lineTo(bwR, bwT); ctx.lineTo(bwR, bwB); ctx.lineTo(W, H); ctx.closePath(); ctx.fill();
  const rwGrad = ctx.createLinearGradient(W, 0, bwR, 0);
  rwGrad.addColorStop(0, 'rgba(0,0,0,.06)');
  rwGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = rwGrad;
  ctx.beginPath(); ctx.moveTo(W, 0); ctx.lineTo(bwR, bwT); ctx.lineTo(bwR, bwB); ctx.lineTo(W, H); ctx.closePath(); ctx.fill();

  const floorGrad = ctx.createLinearGradient(0, bwB, 0, H);
  floorGrad.addColorStop(0, cfg.floor2);
  floorGrad.addColorStop(1, cfg.floor1);
  ctx.fillStyle = floorGrad;
  ctx.beginPath(); ctx.moveTo(0, H); ctx.lineTo(bwL, bwB); ctx.lineTo(bwR, bwB); ctx.lineTo(W, H); ctx.closePath(); ctx.fill();

  ctx.strokeStyle = cfg.trim + '25';
  ctx.lineWidth = 1;
  for (let r = 0; r <= 6; r++) {
    const t = r / 6;
    const lx = t * bwL, rx = W + t * (bwR - W), y = H + t * (bwB - H);
    ctx.beginPath(); ctx.moveTo(lx, y); ctx.lineTo(rx, y); ctx.stroke();
  }
  for (let c = 0; c <= 8; c++) {
    const t = c / 8;
    ctx.beginPath(); ctx.moveTo(bwL + t * (bwR - bwL), bwB); ctx.lineTo(t * W, H); ctx.stroke();
  }

  ctx.strokeStyle = cfg.trim;
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(0, H); ctx.lineTo(bwL, bwB); ctx.lineTo(bwR, bwB); ctx.lineTo(W, H); ctx.stroke();
  ctx.beginPath(); ctx.rect(bwL, bwT, bwR - bwL, bwB - bwT); ctx.stroke();
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(bwL, bwT); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W, 0); ctx.lineTo(bwR, bwT); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, H); ctx.lineTo(bwL, bwB); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W, H); ctx.lineTo(bwR, bwB); ctx.stroke();

  ctx.fillStyle = cfg.trim;
  ctx.fillRect(bwL, bwB - 6, bwR - bwL, 6);

  return { bwL, bwR, bwT, bwB };
}

function drawBedroom(ctx, W, H, cfg) {
  const r = perspectiveRoom(ctx, W, H, cfg);
  const rw = r.bwR - r.bwL, rh = r.bwB - r.bwT;

  const bedX = r.bwL + 8, bedY = r.bwB - rh * .7, bedW = rw * .36, bedH = rh * .65;
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(bedX, bedY, bedW, bedH);
  ctx.fillStyle = '#795548';
  ctx.fillRect(bedX + 5, bedY + 5, bedW - 10, bedH - 5);
  const sheetGrad = ctx.createLinearGradient(bedX, bedY, bedX, bedY + bedH);
  sheetGrad.addColorStop(0, '#E3F2FD');
  sheetGrad.addColorStop(1, '#BBDEFB');
  ctx.fillStyle = sheetGrad;
  ctx.fillRect(bedX + 10, bedY + 14, bedW - 20, bedH * .5);
  ctx.fillStyle = '#4E342E';
  ctx.fillRect(bedX, bedY, bedW, 14);
  ctx.fillRect(bedX, bedY, 6, bedH);

  const nsX = r.bwL + rw * .38, nsY = r.bwB - rh * .38, nsW = rw * .1, nsH = rh * .34;
  ctx.fillStyle = '#6D4C41';
  ctx.fillRect(nsX, nsY, nsW, nsH);
  ctx.fillStyle = '#8D6E63';
  ctx.fillRect(nsX + 3, nsY + 3, nsW - 6, nsH * .45);
  ctx.fillRect(nsX + 3, nsY + nsH * .52, nsW - 6, nsH * .45);
  ctx.fillStyle = '#A1887F';
  ctx.fillRect(nsX, nsY, nsW, 5);

  const dkX = r.bwL + rw * .52, dkY = r.bwB - rh * .42, dkW = rw * .28, dkH = rh * .38;
  ctx.fillStyle = '#A1887F';
  ctx.fillRect(dkX, dkY, dkW, 10);
  ctx.fillStyle = '#8D6E63';
  ctx.fillRect(dkX + 8, dkY + 10, 10, dkH - 10);
  ctx.fillRect(dkX + dkW - 18, dkY + 10, 10, dkH - 10);
  ctx.fillStyle = '#6D4C41';
  ctx.fillRect(dkX + 4, dkY + dkH * .4, dkW - 8, 6);

  const shX = r.bwR - rw * .2, shY = r.bwT + rh * .12, shW = rw * .16, shH = rh * .55;
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(shX, shY, shW, shH);
  ctx.fillStyle = '#6D4C41';
  for (let s = 0; s < 3; s++) {
    ctx.fillRect(shX + 3, shY + 4 + s * (shH / 3), shW - 6, 5);
  }

  const wX = r.bwL + rw * .32, wY = r.bwT + 16, wW = rw * .22, wH = rh * .38;
  const skyGrad = ctx.createLinearGradient(wX, wY, wX, wY + wH);
  skyGrad.addColorStop(0, '#64B5F6');
  skyGrad.addColorStop(1, '#90CAF9');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(wX, wY, wW, wH);
  ctx.strokeStyle = '#F5F5F5';
  ctx.lineWidth = 5;
  ctx.strokeRect(wX, wY, wW, wH);
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(wX + wW / 2, wY); ctx.lineTo(wX + wW / 2, wY + wH); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(wX, wY + wH / 2); ctx.lineTo(wX + wW, wY + wH / 2); ctx.stroke();

  const lightGrad = ctx.createRadialGradient(wX + wW / 2, wY + wH / 2, 0, wX + wW / 2, wY + wH / 2, wW);
  lightGrad.addColorStop(0, 'rgba(255,248,225,.15)');
  lightGrad.addColorStop(1, 'rgba(255,248,225,0)');
  ctx.fillStyle = lightGrad;
  ctx.fillRect(wX - wW * .5, wY, wW * 2, wH * 2);
}

function drawKitchen(ctx, W, H, cfg) {
  const r = perspectiveRoom(ctx, W, H, cfg);
  const rw = r.bwR - r.bwL, rh = r.bwB - r.bwT;

  const cY = r.bwB - rh * .48, cH = rh * .48;
  const counterGrad = ctx.createLinearGradient(0, cY, 0, cY + cH);
  counterGrad.addColorStop(0, '#6D4C41');
  counterGrad.addColorStop(1, '#5D4037');
  ctx.fillStyle = counterGrad;
  ctx.fillRect(r.bwL + 4, cY, rw * .62, cH);
  const topGrad = ctx.createLinearGradient(0, cY, 0, cY + 12);
  topGrad.addColorStop(0, '#D7CCC8');
  topGrad.addColorStop(1, '#BCAAA4');
  ctx.fillStyle = topGrad;
  ctx.fillRect(r.bwL + 4, cY, rw * .62, 12);

  const stX = r.bwL + rw * .08, stY = cY + 16;
  ctx.fillStyle = '#263238';
  ctx.fillRect(stX, stY, rw * .18, rh * .28);
  ctx.fillStyle = '#37474F';
  ctx.fillRect(stX + 4, stY + 4, rw * .18 - 8, rh * .28 - 8);
  for (let i = 0; i < 4; i++) {
    const cx = stX + rw * .045 + (i % 2) * rw * .08;
    const cy = stY + rh * .06 + Math.floor(i / 2) * rh * .12;
    ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2);
    ctx.fillStyle = '#455A64'; ctx.fill();
    ctx.strokeStyle = '#F44336'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.stroke();
  }

  const fX = r.bwR - rw * .24, fY = r.bwT + rh * .06, fW = rw * .20, fH = rh * .90;
  const fridgeGrad = ctx.createLinearGradient(fX, fY, fX + fW, fY);
  fridgeGrad.addColorStop(0, '#ECEFF1');
  fridgeGrad.addColorStop(1, '#CFD8DC');
  ctx.fillStyle = fridgeGrad;
  ctx.fillRect(fX, fY, fW, fH);
  ctx.strokeStyle = '#90A4AE';
  ctx.lineWidth = 2;
  ctx.strokeRect(fX, fY, fW, fH);
  ctx.beginPath(); ctx.moveTo(fX, fY + fH * .38); ctx.lineTo(fX + fW, fY + fH * .38); ctx.stroke();
  ctx.fillStyle = '#78909C';
  ctx.fillRect(fX + fW - 10, fY + fH * .12, 5, 24);
  ctx.fillRect(fX + fW - 10, fY + fH * .52, 5, 24);

  const cabH = rh * .28;
  for (let c = 0; c < 3; c++) {
    const cx = r.bwL + 8 + c * (rw * .19 + 4);
    const cabGrad = ctx.createLinearGradient(cx, r.bwT + 8, cx, r.bwT + 8 + cabH);
    cabGrad.addColorStop(0, '#8D6E63');
    cabGrad.addColorStop(1, '#6D4C41');
    ctx.fillStyle = cabGrad;
    ctx.fillRect(cx, r.bwT + 8, rw * .18, cabH);
    ctx.strokeStyle = '#5D4037';
    ctx.lineWidth = 2;
    ctx.strokeRect(cx, r.bwT + 8, rw * .18, cabH);
    ctx.fillStyle = '#A1887F';
    ctx.fillRect(cx + rw * .08, r.bwT + 8 + cabH - 14, 12, 5);
  }

  const tileY = r.bwT + 8 + cabH + 6;
  const tileH = cY - tileY - 4;
  if (tileH > 0) {
    ctx.fillStyle = '#FAFAFA';
    ctx.fillRect(r.bwL + 4, tileY, rw * .62, tileH);
    ctx.strokeStyle = '#E0E0E0';
    ctx.lineWidth = 1;
    const ts = 18;
    for (let ty = tileY; ty < tileY + tileH; ty += ts) {
      ctx.beginPath(); ctx.moveTo(r.bwL + 4, ty); ctx.lineTo(r.bwL + 4 + rw * .62, ty); ctx.stroke();
    }
    for (let tx = r.bwL + 4; tx < r.bwL + 4 + rw * .62; tx += ts) {
      ctx.beginPath(); ctx.moveTo(tx, tileY); ctx.lineTo(tx, tileY + tileH); ctx.stroke();
    }
  }
}

function drawLiving(ctx, W, H, cfg) {
  const r = perspectiveRoom(ctx, W, H, cfg);
  const rw = r.bwR - r.bwL, rh = r.bwB - r.bwT;

  const sX = r.bwL + rw * .05, sY = r.bwB - rh * .55, sW = rw * .40, sH = rh * .40;
  const sofaGrad = ctx.createLinearGradient(sX, sY, sX, sY + sH);
  sofaGrad.addColorStop(0, '#5D4037');
  sofaGrad.addColorStop(1, '#4E342E');
  ctx.fillStyle = sofaGrad;
  ctx.fillRect(sX, sY - 12, sW, sH + 12);
  ctx.fillStyle = '#6D4C41';
  ctx.fillRect(sX + 8, sY, sW - 16, sH - 12);
  ctx.fillStyle = '#795548';
  ctx.fillRect(sX, sY - 12, 14, sH + 12);
  ctx.fillRect(sX + sW - 14, sY - 12, 14, sH + 12);
  for (let i = 0; i < 3; i++) {
    ctx.fillStyle = '#8D6E63';
    ctx.fillRect(sX + 14 + i * ((sW - 28) / 3), sY + 4, (sW - 34) / 3, sH - 20);
  }
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(sX + 8, sY + sH - 14, sW - 16, 14);

  const tX = r.bwL + rw * .18, tY = r.bwB - rh * .14, tW = rw * .26, tH2 = 10;
  ctx.fillStyle = '#A1887F';
  ctx.fillRect(tX, tY, tW, tH2);
  ctx.fillStyle = '#8D6E63';
  ctx.fillRect(tX + 12, tY + tH2, 8, 36);
  ctx.fillRect(tX + tW - 20, tY + tH2, 8, 36);

  const tvX = r.bwL + rw * .32, tvY = r.bwT + 12, tvW = rw * .32, tvH = rh * .38;
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(tvX, tvY, tvW, tvH);
  const scrGrad = ctx.createLinearGradient(tvX, tvY, tvX + tvW, tvY + tvH);
  scrGrad.addColorStop(0, '#1e3a5f');
  scrGrad.addColorStop(0.5, '#0d2137');
  scrGrad.addColorStop(1, '#1e3a5f');
  ctx.fillStyle = scrGrad;
  ctx.fillRect(tvX + 5, tvY + 5, tvW - 10, tvH - 10);
  ctx.fillStyle = '#333';
  ctx.fillRect(tvX + tvW * .38, tvY + tvH, tvW * .24, 8);
  ctx.fillRect(tvX + tvW * .22, tvY + tvH + 8, tvW * .56, 5);

  const shX = r.bwR - rw * .22, shY = r.bwT + rh * .08, shW = rw * .18, shH = rh * .78;
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(shX, shY, shW, shH);
  ctx.fillStyle = '#6D4C41';
  for (let s = 0; s < 4; s++) {
    const sy = shY + s * (shH / 4);
    ctx.fillRect(shX + 3, sy, shW - 6, 5);
  }

  const rugCx = tX + tW / 2, rugCy = r.bwB + (H - r.bwB) * .38;
  ctx.beginPath();
  ctx.ellipse(rugCx, rugCy, rw * .24, (H - r.bwB) * .3, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#A5D6A720';
  ctx.fill();
  ctx.strokeStyle = '#66BB6A30';
  ctx.lineWidth = 3;
  ctx.stroke();

  const tbX = r.bwL * .25, tbY = H - 90;
  ctx.fillStyle = '#FFB74D';
  ctx.fillRect(tbX, tbY, 80, 58);
  ctx.strokeStyle = '#F57C00';
  ctx.lineWidth = 2;
  ctx.strokeRect(tbX, tbY, 80, 58);
  ctx.fillStyle = '#FF9800';
  ctx.fillRect(tbX - 4, tbY, 88, 9);
}

function randomFloorPos() {
  return {
    x: 0.12 + Math.random() * 0.76,
    y: 0.64 + Math.random() * 0.26
  };
}

function initGame() {
  document.getElementById('roomTitle').textContent = config.name;
  document.getElementById('scoreVal').textContent = '0/' + totalItems;
  document.getElementById('progressFill').style.background = config.progressColor;

  const ob = document.getElementById('overlayBox');
  ob.style.background = config.overlayBg;
  ob.style.border = '4px solid ' + config.overlayBorder;
  document.getElementById('overlayTitle').style.color = config.overlayTitleColor;

  const usedStartPositions = [];

  selectedItems.forEach((it, i) => {
    const tz = document.createElement('div');
    tz.className = 'target-zone';
    tz.style.left = (it.targetX * W - it.targetW / 2) + 'px';
    tz.style.top = (it.targetY * H - it.targetH / 2) + 'px';
    tz.style.width = it.targetW + 'px';
    tz.style.height = it.targetH + 'px';
    tz.innerHTML = '<span class="target-ghost">' + it.emoji + '</span><span class="target-label">' + it.targetLabel + '</span>';
    gameLayer.appendChild(tz);
    targetEls.push(tz);

    const el = document.createElement('div');
    el.className = 'drag-item';
    el.textContent = it.emoji;
    el.dataset.index = i;
    el.dataset.placed = 'false';

    let pos, tries = 0;
    do {
      pos = randomFloorPos();
      tries++;
    } while (tries < 100 && usedStartPositions.some(p => Math.hypot(p.x - pos.x, p.y - pos.y) < 0.12));
    usedStartPositions.push(pos);

    const rot = (Math.random() - 0.5) * 35;
    const px = pos.x * W - 36;
    const py = pos.y * H - 36;
    el.style.left = px + 'px';
    el.style.top = py + 'px';
    el.style.transform = 'rotate(' + rot + 'deg)';
    el.dataset.homeX = px;
    el.dataset.homeY = py;
    el.dataset.homeRot = rot;
    gameLayer.appendChild(el);
    itemEls.push(el);
  });

  startTimer();
}

function startTimer() {
  timerInterval = setInterval(() => {
    if (gameOver) return;
    elapsed++;
    const m = Math.floor(elapsed / 60);
    const s = elapsed % 60;
    document.getElementById('timerVal').textContent = m + ':' + (s < 10 ? '0' : '') + s;
  }, 1000);
}

function updateProgress() {
  const pct = (placedCount / totalItems) * 100;
  document.getElementById('progressFill').style.width = pct + '%';
  document.getElementById('progressText').textContent = placedCount + ' / ' + totalItems + ' items placed';
  document.getElementById('scoreVal').textContent = placedCount + '/' + totalItems;
}

function checkDrop(el, dropX, dropY) {
  const idx = parseInt(el.dataset.index);
  const it = selectedItems[idx];
  const tz = targetEls[idx];
  const tr = tz.getBoundingClientRect();
  const cx = tr.left + tr.width / 2, cy = tr.top + tr.height / 2;
  const dist = Math.hypot(dropX - cx, dropY - cy);

  if (dist < Math.max(tr.width, tr.height) * 0.75) {
    el.dataset.placed = 'true';
    el.classList.remove('dragging');
    el.classList.add('placed');
    el.style.left = (it.targetX * W - el.offsetWidth / 2) + 'px';
    el.style.top = (it.targetY * H - el.offsetHeight / 2) + 'px';
    el.style.transform = 'rotate(0deg)';
    tz.classList.add('filled');
    placedCount++;
    updateProgress();
    spawnSparkles(dropX, dropY);
    playSound(true);
    if (placedCount >= totalItems) endGame();
  } else {
    el.classList.add('wrong');
    playSound(false);
    setTimeout(() => {
      el.classList.remove('wrong', 'dragging');
      el.style.left = el.dataset.homeX + 'px';
      el.style.top = el.dataset.homeY + 'px';
      el.style.transform = 'rotate(' + el.dataset.homeRot + 'deg)';
    }, 420);
  }
}

function spawnSparkles(x, y) {
  const sparks = ['\u2728', '\u2B50', '\u26A1', '\u2764\uFE0F', '\u2705'];
  for (let i = 0; i < 10; i++) {
    const s = document.createElement('div');
    s.className = 'sparkle';
    s.textContent = sparks[i % sparks.length];
    s.style.left = x + 'px';
    s.style.top = y + 'px';
    const angle = (i / 10) * Math.PI * 2;
    const d = 50 + Math.random() * 70;
    s.style.setProperty('--sx', (Math.cos(angle) * d) + 'px');
    s.style.setProperty('--sy', (Math.sin(angle) * d) + 'px');
    gameLayer.appendChild(s);
    s.addEventListener('animationend', () => s.remove());
  }
}

function playSound(success) {
  try {
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    if (success) {
      [523.25, 659.25, 783.99].forEach((f, i) => {
        const o = ac.createOscillator(), g = ac.createGain();
        o.connect(g); g.connect(ac.destination);
        o.frequency.value = f; o.type = 'sine';
        const t = ac.currentTime + i * 0.07;
        g.gain.setValueAtTime(0.18, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        o.start(t); o.stop(t + 0.3);
      });
    } else {
      const o = ac.createOscillator(), g = ac.createGain();
      o.connect(g); g.connect(ac.destination);
      o.frequency.value = 180; o.type = 'sawtooth';
      g.gain.setValueAtTime(0.15, ac.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.3);
      o.start(); o.stop(ac.currentTime + 0.3);
    }
  } catch (_) {}
}

function endGame() {
  gameOver = true;
  clearInterval(timerInterval);
  setTimeout(() => {
    const m = Math.floor(elapsed / 60);
    const s = elapsed % 60;
    document.getElementById('overlayTitle').textContent = '\u2728 Sparkling Clean! \u2728';
    document.getElementById('overlayMsg').innerHTML =
      'Time: ' + m + ':' + (s < 10 ? '0' : '') + s + '<br>All ' + totalItems + ' items in their place!';
    document.getElementById('winOverlay').classList.add('show');
  }, 500);
}

function highlightTargets(x, y) {
  targetEls.forEach(tz => {
    if (tz.classList.contains('filled')) return;
    const tr = tz.getBoundingClientRect();
    const cx = tr.left + tr.width / 2, cy = tr.top + tr.height / 2;
    tz.classList.toggle('active', Math.hypot(x - cx, y - cy) < Math.max(tr.width, tr.height) * 0.9);
  });
}

function clearHighlights() { targetEls.forEach(tz => tz.classList.remove('active')); }

function getItemAt(x, y) {
  for (let i = itemEls.length - 1; i >= 0; i--) {
    const el = itemEls[i];
    if (el.dataset.placed === 'true') continue;
    const r = el.getBoundingClientRect();
    if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return el;
  }
  return null;
}

const activeDrags = new Map();

gameLayer.addEventListener('touchstart', e => {
  if (gameOver) return;
  e.preventDefault();
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    const el = getItemAt(t.clientX, t.clientY);
    if (!el) continue;
    el.classList.add('dragging');
    el.style.transform = 'rotate(0deg) scale(1.15)';
    const r = el.getBoundingClientRect();
    activeDrags.set(t.identifier, { el, offX: t.clientX - r.left, offY: t.clientY - r.top });
  }
}, { passive: false });

gameLayer.addEventListener('touchmove', e => {
  if (gameOver) return;
  e.preventDefault();
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    const d = activeDrags.get(t.identifier);
    if (!d) continue;
    d.el.style.left = (t.clientX - d.offX) + 'px';
    d.el.style.top = (t.clientY - d.offY) + 'px';
    highlightTargets(t.clientX, t.clientY);
  }
}, { passive: false });

gameLayer.addEventListener('touchend', e => {
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    const d = activeDrags.get(t.identifier);
    if (!d) { activeDrags.delete(t.identifier); continue; }
    clearHighlights();
    checkDrop(d.el, t.clientX, t.clientY);
    activeDrags.delete(t.identifier);
  }
});

gameLayer.addEventListener('touchcancel', e => {
  for (let i = 0; i < e.changedTouches.length; i++) {
    const t = e.changedTouches[i];
    const d = activeDrags.get(t.identifier);
    if (d) {
      d.el.classList.remove('dragging');
      d.el.style.left = d.el.dataset.homeX + 'px';
      d.el.style.top = d.el.dataset.homeY + 'px';
      d.el.style.transform = 'rotate(' + d.el.dataset.homeRot + 'deg)';
    }
    activeDrags.delete(t.identifier);
  }
  clearHighlights();
});

let mouseDrag = null;

gameLayer.addEventListener('mousedown', e => {
  if (gameOver || e.button !== 0) return;
  const el = getItemAt(e.clientX, e.clientY);
  if (!el) return;
  el.classList.add('dragging');
  el.style.transform = 'rotate(0deg) scale(1.15)';
  const r = el.getBoundingClientRect();
  mouseDrag = { el, offX: e.clientX - r.left, offY: e.clientY - r.top };
});

window.addEventListener('mousemove', e => {
  if (!mouseDrag) return;
  mouseDrag.el.style.left = (e.clientX - mouseDrag.offX) + 'px';
  mouseDrag.el.style.top = (e.clientY - mouseDrag.offY) + 'px';
  highlightTargets(e.clientX, e.clientY);
});

window.addEventListener('mouseup', e => {
  if (!mouseDrag) return;
  clearHighlights();
  checkDrop(mouseDrag.el, e.clientX, e.clientY);
  mouseDrag = null;
});

resize();
initGame();
</script>
</body>
</html>
